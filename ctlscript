#!/bin/bash

usage() {
    echo "Usage: ctlscript [--system] [command]"
    echo
    echo "Install configuration files to the system or update the"
    echo "configuration files here with those of the system."
    echo
    echo "  ctlscript [--scope system|home] install <file>		- copy the files from the working tree of the repository to the system"
    echo "  ctlscript [--scope system|home] update				- copy the files from the system to the working tree of the repository"
	echo "  ctlscript restore <dir>		- restore a backap made by the install command (dir is a directory inside the backup/ folder)"
}


# Parse the options
scope="all"
while [ -n "$1" ]; do
	case "$1" in
		--scope)
			shift
			case $1 in
				system|home)
					scope=$1
					shift
					;;
				*)
					echo "Unknown type: $1"
					exit 1;;
			esac
			;;
		--*)
			echo "Unknown option: $1"
			usage
			exit 1;;
		*)
			break;;
	esac
done


# Parse the commands
if [ -n $1 ]; then
	case "$1" in
		install|update|restore)
			command=$1
			shift
			;;
		*)
			echo "Unknown command: $1"
			usage
			exit 1;;
	esac
fi
if [ -n "$1" ]; then
	case "$command" in
		install)
			# The install command has an additional scope which allows
		    # a single file from the files directory to be choosen
			if [ -f "$1" ]; then
				scope="file"
				file="$1"
				shift
			else
				echo "Given file doesn't exist. Please specifiy a file from the files directory (i.e files/path/to/file)"
				echo "or a scope with the --scope argument (valid values are 'system' and 'home')."
				exit 1
			fi
			;;
		restore)
			# The restore command NEEDS a backup directory
			if [ -d "$1" ]; then
				backupdir="$1"
				shift
			else
				echo "Given directory doesn't exist. Please specify a directory form the backup directory (i.e backup/<timestamp>)."
				exit 1
			fi
			;;
		*)
			echo "This command doesn't accept any additional arguments."
			echo "Use 'ctlscript --help' for more information."
			exit 1
			;;
	esac
fi

##########################################################################################

# Retrieves the real paths on the system from the structure of the files directory
# and depending on the options given
getsystempaths()
{
	case "$scope" in
		file)
			files="$file"
			;;
		system)
			files=$(find files -not \( -path files/home -prune \) -type f)
			;;
		home)
			files=$(find files/home/ -type f)
			;;
		all)
			files=$(find files -type f)
			;;
	esac

	for item in $files; do
		name=${item//files/}
		if [[ "$name" =~ /home/(.*) ]]; then
			name="$HOME/${BASH_REMATCH[1]}"
		fi
		echo "$name"
	done
}

# Copy from the working folder to the system
if [ "$command" = "install" ]; then
	# Create a backup associated to the actual timestamp
	timestamp=$(date +%s)
	mkdir -p backup/"$timestamp"

	# Copy the respective file in the home directory making first a backup
	files=$(getsystempaths)
	getsystempaths; exit
	for item in $files; do 
		if [ -f "$item" ]; then
			cp --parents $item backup/"$timestamp"/
		fi
		reponame=${item//$HOME/\/home}
		if [[ "$item" =~ $HOME/(.*) ]]; then
			#cp files"$reponame" "$item"
		else
			#sudo cp files"$reponame" "$item"
		fi
	done
	exit 1
fi


# Copy from the system to the working folder
if [ "$command" = "update" ]; then
	files=$(getsystempaths)
	for item in $files; do
		reponame=${item//$HOME/\/home}
		cp "$item" files"$reponame" 
	done
	exit 1
fi


# Restore the system file form a backup
if [ "$command" = "restore" ]; then
	files=$(find "backup/$backupdir" -type f)
	for item in $files; do
		name=${item#backup\/$backupdir}
		cp "$item" "$name" 
	done
	exit 1
fi
